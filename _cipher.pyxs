
<%!

modes = 'ecb ctr cbc cfb ofb'.split()
simple_modes = 'cbc cfb ofb'.split()
ciphers = 'aes rijndael des blowfish'.split()

%>

modes = ${repr(modes)}
simple_modes = ${repr(simple_modes)}
ciphers = ${repr(ciphers)}

cdef extern from "tomcrypt.h":

	int CRYPT_OK
	int CTR_COUNTER_BIG_ENDIAN
	char * error_to_string(int err)
	
	# Generic symmetric key, and for all of the supported modes.
	<%!
	def symmetric_xxx(name):
		return """ctypedef struct symmetric_%s "symmetric_%s":
		pass""" % (name, name.upper())
	%>
	% for name in modes:
	${symmetric_xxx(name)}
	% endfor
	
	<%!
	# Define some functions for pulling in all the cipher modes.
	def xxx_start(name):
		return 'int %(name)s_start(int cipher, unsigned char *iv, unsigned char *key, int keylen, int num_rounds, symmetric_%(name)s *%(name)s)' % locals()
	def xxx_encrypt(name):
		return 'int %(name)s_encrypt(unsigned char *pt, unsigned char *ct, long len, symmetric_%(name)s *%(name)s)' % locals()
	def xxx_decrypt(name):
		return 'int %(name)s_decrypt(unsigned char *ct, unsigned char *pt, long len, symmetric_%(name)s *%(name)s)' % locals()
	def xxx_done(name):
		return 'int %(name)s_done(symmetric_%(name)s *%(name)s)' % locals()
	%>
	# Pull in all the cipher functions for all the modes.
	int ecb_start(int cipher, unsigned char *key, int keylen, int num_rounds, symmetric_ecb *ecb)
	int ctr_start(int cipher, unsigned char *iv, unsigned char *key, int keylen, int num_rounds, int ctr_mode, symmetric_ctr *ctr)
	% for name in simple_modes:
	${xxx_start(name)}
	% endfor
	% for name in modes:
	${xxx_encrypt(name)}
	${xxx_decrypt(name)}
	${xxx_done(name)}
	% endfor
	
	# Cipher descriptor.
	cdef struct cipher_desc "ltc_cipher_descriptor":
		char * name
		int min_key_length
		int max_key_length
		int block_length
		int default_rounds
		# int setup(char *key, int keylen, int rounds, symmetric_key *skey)
	
	# The array which contains the descriptors once setup.
	cipher_desc cipher_descriptors "cipher_descriptor" []
	
	# The descriptors themselves.
	% for name in ciphers:
	cipher_desc ${name}_desc
	% endfor
		
	# Functions for registering and finding the registered ciphers.
	int register_cipher(cipher_desc *cipher)
	int find_cipher(char * name)


# Register all of the ciphers.
% for name in ciphers:
register_cipher(&${name}_desc)
% endfor


class CryptoError(Exception):
	
	def __init__(self, err):
		Exception.__init__(self, error_to_string(err), err)

cdef class Cipher(object):
	
	cdef int cipher_i
	cdef cipher_desc cipher
	
	% for mode in modes:
	cdef symmetric_${mode} ${mode}
	% endfor
	
	def __init__(self, key, cipher='aes', mode='cbc'):
		cdef int res
		
		self.cipher_i = find_cipher(cipher)
		if self.cipher_i < 0:
			raise ValueError('could not find %r' % cipher)
		self.cipher = cipher_descriptors[self.cipher_i]
		self.set_key(key)
		
	def set_key(self, key):
		iv = '\0' * self.block_length
		# Setup all of the mode states.
		res = ecb_start(self.cipher_i, key, len(key), 0, &self.ecb)
		if res != CRYPT_OK:
			raise CryptoError(res)
		res = ctr_start(self.cipher_i, iv, key, len(key), 0, CTR_COUNTER_BIG_ENDIAN, &self.ctr)
		if res != CRYPT_OK:
			raise CryptoError(res)
		% for mode in simple_modes:
		res = ${mode}_start(self.cipher_i, iv, key, len(key), 0, &self.${mode})
		if res != CRYPT_OK:
			raise CryptoError(res)
		% endfor
	
	@property
	def name(self):
		return self.cipher.name
	
	@property
	def min_key_length(self):
		return self.cipher.min_key_length
	
	@property
	def max_key_length(self):
		return self.cipher.max_key_length
		
	@property
	def block_length(self):
		return self.cipher.block_length
	
	@property
	def default_rounds(self):
		return self.cipher.default_rounds
	
	% for mode in modes:
	
	def ${mode}_encrypt(self, plaintext):
		cdef int res, length
		cdef unsigned char *pt, *ct
		length = len(plaintext)
		ciphertext = '\0' * length
		pt = plaintext
		ct = ciphertext
		res = ${mode}_encrypt(pt, ct, length, &self.${mode})
		if res != CRYPT_OK:
			raise CryptoError(res)
		return ciphertext
		
	def ${mode}_decrypt(self, ciphertext):
		cdef int res, length
		cdef unsigned char *pt, *ct
		length = len(ciphertext)
		plaintext = '\0' * length
		pt = plaintext
		ct = ciphertext
		res = ${mode}_decrypt(ct, pt, length, &self.${mode})
		if res != CRYPT_OK:
			raise CryptoError(res)
		return plaintext
	
	% endfor
		
	

