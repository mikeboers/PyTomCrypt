
How to dispatch to the differing methods for each mode:
    1. Dispatch to the different methods in Python.
        - Takes about 300 ns per block.
    2. Build a class for each of the modes. The dispatching is done before it
       even compiles.
        - Takes about 292-294 ns per block.
    3. Save pointers to the en/decrypt functions in the Cipher class.
        - This relies upon the compiler automatically casting from void* to
          whatever it should be (symetric_XXX*)
        - Takes about 295 ns per block.
    4. Build array of pointer functions and store the index into that array in
       the class. No more malloc!
        - Still relies upon the compiler doing the right thing with void*
        - Takes about 292-293 per block.



Organize this into a standard package layout:
    PyTomCrypt/
        tomcrypt/
            __init__.py
            <everything here>
        setup.py
        libtomcrypt-...
        README.txt
        LICENSE.txt

Stop thinking about making the ciphers register when you need them. It takes
only 83 microseconds to register them all.

Rename the cipher.Descriptor.keysize to key_length, or figure out how to
normalize the differences.

Add: EAX (page 46), PCB(50), CCM(53), and GCM(56)

