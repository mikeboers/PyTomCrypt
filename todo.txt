
- Have classes build for each of the modes. This way we don't need to dispatch
  at every call.
    - First time the difference to see if it even matters.
        Takes approx 290 ps per block, instead of 300.
    - Decide upon the API for this:
        - Could pass the cipher to the mode class: cipher = CipherCBC('aes')
        - Could have a class for each combination: cipher = AES_CBC('key')
        - Could have a function which picks from one of the above for you:
            cipher = build(mode='cbc', cipher='aes')
        - Could have __new__ on Cipher* pick the right class depending on the
          mode and cipher.
- OR, IFF we don't have to explicitly cast the symmetric_*, then figure out
  how to save pointers to functions and pick those in the setup.
  
  I have now tried this, and it actually went slightly slower. Ie. 161ms
  instead of 159ms.
  
  With the better timer it is at 295ps instead of 300.

Decide on a naming scheme for cipher specs and modes:
    aes vs AES
    ECB vs ecb vs ECBCipher
    Cipher vs cipher vs build_cipher vs setup_cipher (this is a function)

Organize this into a standard package layout:
    PyTomCrypt/
        tomcrypt/
            __init__.py
            <everything here>
        setup.py
        libtomcrypt-...
        README.txt
        LICENSE.txt

Stop thinking about making the ciphers register when you need them. It takes
only 83 microseconds to register them all.